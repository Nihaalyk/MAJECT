<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Behavioral Analyzer - Minimal Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .status-running {
            background-color: #28a745;
        }

        .status-waiting {
            background-color: #ffc107;
        }

        .status-error {
            background-color: #dc3545;
        }

        .data-card {
            transition: all 0.3s ease;
        }

        .data-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: bold;
        }

        .metric-label {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .calibration-panel {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .calibration-progress {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin: 10px 0;
        }

        .calibration-progress-bar {
            background-color: #28a745;
            height: 100%;
            transition: width 0.3s ease;
        }

        .detected-objects-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 120px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }

        .object-badge {
            display: inline-flex;
            align-items: center;
            padding: 8px 12px;
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            margin: 2px;
        }

        .object-badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .object-badge .confidence {
            margin-left: 8px;
            font-size: 0.75rem;
            opacity: 0.9;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
        }

        .scene-stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #6c757d;
        }

        .stat-value {
            font-weight: bold;
            color: #495057;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-dark bg-dark">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">
                <i class="fas fa-brain"></i> Behavioral Analyzer - Minimal Dashboard
            </span>
            <div class="d-flex">
                <span class="badge bg-secondary me-2" id="connection-status">
                    <span class="status-indicator status-waiting"></span> Connecting...
                </span>
                <span class="badge bg-info" id="session-time">00:00:00</span>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3">
        <!-- Status Row -->
        <div class="row mb-3">
            <div class="col-12">
                <div class="alert alert-info" id="status-alert">
                    <i class="fas fa-info-circle"></i> <span id="status-message">Initializing...</span>
                </div>
            </div>
        </div>

        <!-- Main Metrics -->
        <div class="row">
            <!-- Video Analysis -->
            <div class="col-lg-3 col-md-6 mb-3">
                <div class="card data-card">
                    <div class="card-header">
                        <h6><i class="fas fa-smile"></i> Video Analysis</h6>
                    </div>
                    <div class="card-body text-center">
                        <div class="metric-value text-primary" id="current-emotion">Unknown</div>
                        <div class="metric-label">Current Emotion</div>
                        <hr>
                        <div class="row">
                            <div class="col-6">
                                <div class="h5" id="attention-state">Unknown</div>
                                <small class="text-muted">Attention</small>
                            </div>
                            <div class="col-6">
                                <div class="h5" id="posture-state">Unknown</div>
                                <small class="text-muted">Posture</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Audio Analysis -->
            <div class="col-lg-3 col-md-6 mb-3">
                <div class="card data-card">
                    <div class="card-header">
                        <h6><i class="fas fa-microphone"></i> Audio Analysis</h6>
                    </div>
                    <div class="card-body">
                        <div class="mb-2">
                            <strong>Transcription:</strong>
                            <div id="transcription" class="text-muted small">No speech detected</div>
                        </div>
                        <hr>
                        <div class="row text-center">
                            <div class="col-6">
                                <div class="h6" id="audio-emotion">neutral</div>
                                <small class="text-muted">Emotion</small>
                            </div>
                            <div class="col-6">
                                <div class="h6" id="sentiment-score">0.0</div>
                                <small class="text-muted">Sentiment</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Blink Analysis -->
            <div class="col-lg-3 col-md-6 mb-3">
                <div class="card data-card">
                    <div class="card-header">
                        <h6><i class="fas fa-eye"></i> Blink Analysis</h6>
                    </div>
                    <div class="card-body text-center">
                        <div class="metric-value text-success" id="blink-rate">0</div>
                        <div class="metric-label">Blinks/min</div>
                        <hr>
                        <div class="row">
                            <div class="col-6">
                                <div class="h5" id="total-blinks">0</div>
                                <small class="text-muted">Total</small>
                            </div>
                            <div class="col-6">
                                <div class="h5" id="fatigue-level">Normal</div>
                                <small class="text-muted">Fatigue</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Performance -->
            <div class="col-lg-3 col-md-6 mb-3">
                <div class="card data-card">
                    <div class="card-header">
                        <h6><i class="fas fa-tachometer-alt"></i> Performance</h6>
                    </div>
                    <div class="card-body text-center">
                        <div class="metric-value text-info" id="video-fps">0</div>
                        <div class="metric-label">Video FPS</div>
                        <hr>
                        <div class="row">
                            <div class="col-6">
                                <div class="h5" id="session-duration">00:00:00</div>
                                <small class="text-muted">Duration</small>
                            </div>
                            <div class="col-6">
                                <div class="h5" id="object-count">0</div>
                                <small class="text-muted">Objects</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scene Detection Panel -->
        <div class="row mb-3">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h6><i class="fas fa-search"></i> Scene Detection <small class="text-muted">- Objects in
                                View</small></h6>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-8">
                                <div id="detected-objects-container" class="detected-objects-grid">
                                    <div class="text-muted text-center py-3" id="no-objects-message">
                                        <i class="fas fa-eye-slash"></i> No objects detected
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="scene-stats">
                                    <h6 class="mb-3">Detection Summary</h6>
                                    <div class="stat-item mb-2">
                                        <span class="stat-label">Total Objects:</span>
                                        <span class="stat-value" id="total-objects-count">0</span>
                                    </div>
                                    <div class="stat-item mb-2">
                                        <span class="stat-label">Unique Types:</span>
                                        <span class="stat-value" id="unique-types-count">0</span>
                                    </div>
                                    <div class="stat-item mb-2">
                                        <span class="stat-label">Confidence Avg:</span>
                                        <span class="stat-value" id="avg-confidence">0%</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-label">Last Update:</span>
                                        <span class="stat-value" id="scene-last-update">Never</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Raw Data Display -->
        <div class="row">
            <div class="col-8">
                <div class="card">
                    <div class="card-header">
                        <h6><i class="fas fa-code"></i> Raw Data <small class="text-muted">(Last Update: <span
                                    id="last-update">Never</span>)</small></h6>
                    </div>
                    <div class="card-body">
                        <pre id="raw-data" class="small text-muted">No data available</pre>
                    </div>
                </div>
            </div>
            <div class="col-4">
                <div class="card">
                    <div class="card-header">
                        <h6><i class="fas fa-cog"></i> Calibration Status</h6>
                    </div>
                    <div class="card-body">
                        <!-- Calibration Panel -->
                        <div class="calibration-panel" id="calibration-panel" style="display: block;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <small><i class="fas fa-cog fa-spin" id="calibration-icon"></i> <span
                                        id="calibration-label">Calibrating</span></small>
                                <small id="calibration-timer">10.0s</small>
                            </div>
                            <div class="calibration-progress">
                                <div class="calibration-progress-bar" id="calibration-progress" style="width: 0%"></div>
                            </div>
                            <small id="calibration-status">Establishing baseline...</small>
                        </div>

                        <!-- Calibrated Values Summary -->
                        <div class="calibrated-values" id="calibrated-values"
                            style="display: block !important; margin-top: 15px; padding: 15px; background: #28a745 !important; border: 3px solid #20c997 !important; border-radius: 8px; color: white !important;">
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0" style="color: white !important;"><i class="fas fa-chart-line"></i>
                                    Calibrated Values</h6>
                                <button class="btn btn-sm btn-light"
                                    onclick="window.dashboard.testCalibratedValues()">Refresh Values</button>
                            </div>
                            <div class="row">
                                <div class="col-6">
                                    <div class="calibrated-metric">
                                        <small style="color: #e8f5e8;">Blink Rate</small>
                                        <div id="calibrated-blink-rate" class="calibrated-value"
                                            style="color: white; font-weight: bold;">15 blinks/min</div>
                                    </div>
                                </div>
                                <div class="col-6">
                                    <div class="calibrated-metric">
                                        <small style="color: #e8f5e8;">Sentiment</small>
                                        <div id="calibrated-sentiment" class="calibrated-value"
                                            style="color: white; font-weight: bold;">0.75 (+12%)</div>
                                    </div>
                                </div>
                                <div class="col-6 mt-2">
                                    <div class="calibrated-metric">
                                        <small style="color: #e8f5e8;">Emotion</small>
                                        <div id="calibrated-emotion" class="calibrated-value"
                                            style="color: white; font-weight: bold;">Happy</div>
                                    </div>
                                </div>
                                <div class="col-6 mt-2">
                                    <div class="calibrated-metric">
                                        <small style="color: #e8f5e8;">Confidence</small>
                                        <div id="calibrated-attention" class="calibrated-value"
                                            style="color: white; font-weight: bold;">0.89 (+5%)</div>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-2">
                                <small id="calibrated-debug-info" style="color: #e8f5e8;">Debug: HARDCODED TEST VALUES -
                                    If you see this, HTML works!</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        class MinimalDashboard {
            constructor() {
                this.sessionStartTime = Date.now();
                this.updateInterval = null;
                this.latestData = null;
                this.init();
            }

            init() {
                this.startSessionTimer();
                this.startDataPolling();
            }

            startSessionTimer() {
                setInterval(() => {
                    const elapsed = Date.now() - this.sessionStartTime;
                    const hours = Math.floor(elapsed / 3600000);
                    const minutes = Math.floor((elapsed % 3600000) / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);

                    document.getElementById('session-time').textContent =
                        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            startDataPolling() {
                this.updateInterval = setInterval(() => {
                    this.fetchData();
                }, 1000); // Poll every second

                // Initial fetch
                this.fetchData();
            }

            async fetchData() {
                try {
                    const response = await fetch('/api/data');
                    const data = await response.json();
                    this.latestData = data;
                    this.updateDashboard(data);
                    this.updateCalibration(data.calibration || {});
                    this.updateStatus('running', 'Connected - Receiving data');
                } catch (error) {
                    console.error('Error fetching data:', error);
                    this.updateStatus('error', 'Connection error');
                }
            }

            updateDashboard(data) {
                // Update video data
                if (data.video) {
                    document.getElementById('current-emotion').textContent = data.video.emotion || 'Unknown';
                    document.getElementById('attention-state').textContent = data.video.attention_state || 'Unknown';
                    document.getElementById('posture-state').textContent = data.video.posture_state || 'Unknown';
                    document.getElementById('blink-rate').textContent = Math.round(data.video.blink_rate || 0);
                    document.getElementById('total-blinks').textContent = data.video.total_blinks || 0;
                    document.getElementById('fatigue-level').textContent = data.video.fatigue_level || 'Normal';
                    document.getElementById('video-fps').textContent = Math.round(data.video.fps || 0);

                    // Show calibrated values if available
                    if (data.video.blink_rate_calibrated) {
                        const calibrated = data.video.blink_rate_calibrated;
                        const blinkElement = document.getElementById('blink-rate');
                        blinkElement.innerHTML = `${Math.round(calibrated.raw)} <small class="text-muted">(${calibrated.deviation_percent > 0 ? '+' : ''}${calibrated.deviation_percent.toFixed(1)}%)</small>`;
                        blinkElement.title = `Baseline: ${calibrated.baseline.toFixed(1)} - ${calibrated.status}`;
                    }
                }

                // Update audio data
                if (data.audio) {
                    const transcription = data.audio.transcription || 'No speech detected';
                    document.getElementById('transcription').textContent = transcription;
                    document.getElementById('audio-emotion').textContent = data.audio.emotion || 'neutral';
                    document.getElementById('sentiment-score').textContent = (data.audio.sentiment || 0).toFixed(1);

                    // Show calibrated sentiment if available
                    if (data.audio.sentiment_calibrated) {
                        const calibrated = data.audio.sentiment_calibrated;
                        const sentimentElement = document.getElementById('sentiment-score');
                        sentimentElement.innerHTML = `${calibrated.raw.toFixed(1)} <small class="text-muted">(${calibrated.deviation_percent > 0 ? '+' : ''}${calibrated.deviation_percent.toFixed(1)}%)</small>`;
                        sentimentElement.title = `Baseline: ${calibrated.baseline.toFixed(2)} - ${calibrated.status}`;
                    }
                }

                // Update session stats
                if (data.session_stats) {
                    const duration = data.session_stats.session_duration || 0;
                    const hours = Math.floor(duration / 3600);
                    const minutes = Math.floor((duration % 3600) / 60);
                    const seconds = Math.floor(duration % 60);

                    document.getElementById('session-duration').textContent =
                        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }

                // Update object count
                if (data.objects && data.objects.detections) {
                    document.getElementById('object-count').textContent = data.objects.detections.length;
                }

                // Update scene detection
                this.updateSceneDetection(data.objects || {});

                // Update raw data display
                document.getElementById('raw-data').textContent = JSON.stringify(data, null, 2);
                document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
            }

            updateCalibration(calibrationData) {
                const panel = document.getElementById('calibration-panel');
                const progress = document.getElementById('calibration-progress');
                const timer = document.getElementById('calibration-timer');
                const status = document.getElementById('calibration-status');
                const icon = document.getElementById('calibration-icon');
                const label = document.getElementById('calibration-label');
                const calibratedValues = document.getElementById('calibrated-values');

                console.log('Calibration data:', calibrationData); // Debug log

                if (calibrationData.is_calibrating) {
                    panel.style.display = 'block';
                    panel.style.background = 'linear-gradient(135deg, #007bff, #0056b3)';
                    progress.style.width = (calibrationData.progress_percent || 0) + '%';
                    timer.textContent = (calibrationData.time_remaining || 0).toFixed(1) + 's';
                    status.textContent = calibrationData.status || 'Establishing baseline...';
                    icon.className = 'fas fa-cog fa-spin';
                    icon.style.display = 'inline-block';
                    label.textContent = 'Calibrating';
                    calibratedValues.style.display = 'none';
                } else if (calibrationData.progress_percent === 100 || calibrationData.status === 'Complete') {
                    // Show completed calibration
                    panel.style.display = 'block';
                    panel.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                    progress.style.width = '100%';
                    timer.textContent = 'Done';
                    status.innerHTML = '<i class="fas fa-check"></i> Calibrated - Showing calibrated values';
                    icon.className = 'fas fa-check';
                    icon.style.display = 'inline-block';
                    label.textContent = 'Calibrated';

                    console.log('Calibration complete - showing calibrated values section');
                    calibratedValues.style.display = 'block';

                    // Update calibrated values from the latest data
                    console.log('Calling updateCalibratedValuesDisplay...');
                    this.updateCalibratedValuesDisplay();
                } else {
                    // Show waiting state
                    panel.style.display = 'block';
                    panel.style.background = 'linear-gradient(135deg, #6c757d, #495057)';
                    progress.style.width = '0%';
                    timer.textContent = 'Waiting';
                    status.textContent = calibrationData.status || 'Waiting for analyzer...';
                    icon.className = 'fas fa-clock';
                    icon.style.display = 'inline-block';
                    label.textContent = 'Waiting';
                    calibratedValues.style.display = 'none';
                }
            }

            updateCalibratedValuesDisplay() {
                // Get current data to extract calibrated values
                const currentData = this.latestData;
                console.log('=== CALIBRATED VALUES UPDATE ===');
                console.log('updateCalibratedValuesDisplay called with data:', currentData);

                // Always show the calibrated values section
                const calibratedSection = document.getElementById('calibrated-values');
                if (calibratedSection) {
                    calibratedSection.style.display = 'block';
                    console.log('Forced calibrated values section to be visible');
                }

                if (!currentData) {
                    console.log('No current data available - showing placeholder values');
                    document.getElementById('calibrated-blink-rate').innerHTML = 'No Data';
                    document.getElementById('calibrated-sentiment').innerHTML = 'No Data';
                    document.getElementById('calibrated-emotion').innerHTML = 'No Data';
                    document.getElementById('calibrated-attention').innerHTML = 'No Data';
                    document.getElementById('calibrated-debug-info').textContent = 'Debug: No data received';
                    return;
                }

                let updateCount = 0;

                // Update blink rate (check if available)
                if (currentData.video && currentData.video.blink_rate_calibrated) {
                    const blinkCal = currentData.video.blink_rate_calibrated;
                    const deviation = blinkCal.deviation_percent > 0 ? '+' : '';
                    const displayValue = `${Math.round(blinkCal.raw)} <small>(${deviation}${blinkCal.deviation_percent.toFixed(1)}%)</small>`;
                    console.log('Setting blink rate to:', displayValue);
                    document.getElementById('calibrated-blink-rate').innerHTML = displayValue;
                    updateCount++;
                } else {
                    // Show raw blink rate if no calibrated data
                    const rawBlink = currentData.video ? currentData.video.blink_rate || 0 : 0;
                    const displayValue = `${Math.round(rawBlink)} <small>(Raw)</small>`;
                    console.log('Setting blink rate (no calibration) to:', displayValue);
                    document.getElementById('calibrated-blink-rate').innerHTML = displayValue;
                }

                // Update sentiment (this exists)
                if (currentData.audio && currentData.audio.sentiment_calibrated) {
                    const sentCal = currentData.audio.sentiment_calibrated;
                    const deviation = sentCal.deviation_percent > 0 ? '+' : '';
                    const displayValue = `${sentCal.raw.toFixed(2)} <small>(${deviation}${sentCal.deviation_percent.toFixed(1)}%)</small>`;
                    console.log('Setting sentiment to:', displayValue);
                    document.getElementById('calibrated-sentiment').innerHTML = displayValue;
                    updateCount++;
                } else {
                    const rawSentiment = currentData.audio ? currentData.audio.sentiment || 0 : 0;
                    const displayValue = `${rawSentiment.toFixed(2)} <small>(Raw)</small>`;
                    console.log('No sentiment calibrated data found - showing raw:', displayValue);
                    document.getElementById('calibrated-sentiment').innerHTML = displayValue;
                }

                // Update emotion (this exists)
                if (currentData.video && currentData.video.emotion_calibrated) {
                    const emotCal = currentData.video.emotion_calibrated;
                    const statusText = emotCal.is_baseline ? 'Normal' : 'Changed';
                    const displayValue = `${emotCal.raw} <small>(${statusText})</small>`;
                    console.log('Setting emotion (video) to:', displayValue);
                    document.getElementById('calibrated-emotion').innerHTML = displayValue;
                    updateCount++;
                } else if (currentData.audio && currentData.audio.emotion_calibrated) {
                    const emotCal = currentData.audio.emotion_calibrated;
                    const statusText = emotCal.is_baseline ? 'Normal' : 'Changed';
                    const displayValue = `${emotCal.raw} <small>(${statusText})</small>`;
                    console.log('Setting emotion (audio) to:', displayValue);
                    document.getElementById('calibrated-emotion').innerHTML = displayValue;
                    updateCount++;
                } else {
                    const rawEmotion = (currentData.video && currentData.video.emotion) ||
                        (currentData.audio && currentData.audio.emotion) || 'neutral';
                    const displayValue = `${rawEmotion} <small>(Raw)</small>`;
                    console.log('No emotion calibrated data found - showing raw:', displayValue);
                    document.getElementById('calibrated-emotion').innerHTML = displayValue;
                }

                // Update confidence (use audio confidence instead of attention)
                if (currentData.audio && currentData.audio.confidence_calibrated) {
                    const confCal = currentData.audio.confidence_calibrated;
                    const deviation = confCal.deviation_percent > 0 ? '+' : '';
                    const displayValue = `${confCal.raw.toFixed(2)} <small>(${deviation}${confCal.deviation_percent.toFixed(1)}%)</small>`;
                    console.log('Setting confidence to:', displayValue);
                    document.getElementById('calibrated-attention').innerHTML = displayValue;
                    updateCount++;
                } else {
                    const rawConfidence = currentData.audio ? currentData.audio.confidence || 0 : 0;
                    const displayValue = `${rawConfidence.toFixed(2)} <small>(Raw)</small>`;
                    console.log('No confidence calibrated data found - showing raw:', displayValue);
                    document.getElementById('calibrated-attention').innerHTML = displayValue;
                }

                // Update debug info
                const debugInfo = document.getElementById('calibrated-debug-info');
                const timestamp = new Date().toLocaleTimeString();
                debugInfo.textContent = `Debug: Updated ${updateCount} calibrated values at ${timestamp}`;
                console.log(`=== UPDATE COMPLETE: ${updateCount} calibrated values updated ===`);
            }

            updateStatus(status, message) {
                const statusElement = document.getElementById('connection-status');
                const alertElement = document.getElementById('status-alert');
                const messageElement = document.getElementById('status-message');

                const indicator = statusElement.querySelector('.status-indicator');
                indicator.className = `status-indicator status-${status}`;

                statusElement.innerHTML = `<span class="status-indicator status-${status}"></span> ${status === 'running' ? 'Connected' : status === 'waiting' ? 'Waiting' : 'Error'}`;

                messageElement.textContent = message;
                alertElement.className = `alert alert-${status === 'running' ? 'success' : status === 'waiting' ? 'warning' : 'danger'}`;
            }

            testCalibratedValues() {
                console.log('Test button clicked - updating calibrated values');
                this.updateCalibratedValuesDisplay();
            }

            updateSceneDetection(objectsData) {
                const detections = objectsData.detections || [];
                const container = document.getElementById('detected-objects-container');
                const noObjectsMessage = document.getElementById('no-objects-message');

                // Filter for interview-relevant objects only
                const interviewRelevantObjects = this.filterInterviewRelevantObjects(detections);

                // Update summary stats with filtered objects
                document.getElementById('total-objects-count').textContent = interviewRelevantObjects.length;
                document.getElementById('scene-last-update').textContent = new Date().toLocaleTimeString();

                if (interviewRelevantObjects.length === 0) {
                    // Show no relevant objects message
                    container.innerHTML = '<div class="text-muted text-center py-3" id="no-objects-message"><i class="fas fa-eye-slash"></i> No interview-relevant objects detected</div>';
                    document.getElementById('unique-types-count').textContent = '0';
                    document.getElementById('avg-confidence').textContent = '0%';
                    return;
                }

                // Group objects by class and calculate stats
                const objectGroups = {};
                let totalConfidence = 0;

                interviewRelevantObjects.forEach(detection => {
                    const className = detection.class_name;
                    if (!objectGroups[className]) {
                        objectGroups[className] = {
                            name: className,
                            count: 0,
                            totalConfidence: 0,
                            maxConfidence: 0
                        };
                    }
                    objectGroups[className].count++;
                    objectGroups[className].totalConfidence += detection.confidence;
                    objectGroups[className].maxConfidence = Math.max(objectGroups[className].maxConfidence, detection.confidence);
                    totalConfidence += detection.confidence;
                });

                // Update stats
                const uniqueTypes = Object.keys(objectGroups).length;
                const avgConfidence = totalConfidence / detections.length;

                document.getElementById('unique-types-count').textContent = uniqueTypes;
                document.getElementById('avg-confidence').textContent = Math.round(avgConfidence * 100) + '%';

                // Create object badges
                let badgesHtml = '';
                Object.values(objectGroups).forEach(group => {
                    const avgGroupConfidence = group.totalConfidence / group.count;
                    const displayName = this.formatObjectName(group.name);
                    const countText = group.count > 1 ? ` (${group.count})` : '';

                    badgesHtml += `
                        <div class="object-badge" style="background: ${this.getObjectColor(group.name)}">
                            <i class="fas ${this.getObjectIcon(group.name)}"></i>
                            <span class="ms-1">${displayName}${countText}</span>
                            <span class="confidence">${Math.round(avgGroupConfidence * 100)}%</span>
                        </div>
                    `;
                });

                container.innerHTML = badgesHtml;
            }

            filterInterviewRelevantObjects(detections) {
                // Define strict interview-relevant objects only
                const interviewRelevantClasses = [
                    // Person (the interviewee)
                    'person',

                    // Technology & Communication (core interview items)
                    'laptop', 'cell phone', 'keyboard', 'mouse',

                    // Writing & Documentation (only clear items)
                    'book',

                    // Furniture & Setup (basic interview setup)
                    'chair', 'dining table',

                    // Personal Items (common in interviews)
                    'bottle', 'cup'
                ];

                // Process detections with confidence-based filtering
                const processedDetections = [];

                detections.forEach(detection => {
                    const className = detection.class_name.toLowerCase();
                    const confidence = detection.confidence;

                    // Skip very low confidence detections
                    if (confidence < 0.5) {
                        return;
                    }

                    // High confidence + interview relevant = show specific name
                    if (confidence >= 0.8 && interviewRelevantClasses.includes(className)) {
                        processedDetections.push(detection);
                    }
                    // Medium confidence or not in strict list = show as "Object"
                    else if (confidence >= 0.5) {
                        // Create a generic object detection
                        const genericDetection = {
                            ...detection,
                            class_name: 'object',
                            original_class: className,
                            confidence_level: confidence >= 0.7 ? 'medium-high' : 'medium'
                        };
                        processedDetections.push(genericDetection);
                    }
                });

                return processedDetections;
            }

            formatObjectName(className) {
                // Handle generic object case
                if (className === 'object') {
                    return 'Object';
                }

                // Convert class names to more readable format for interview context (strict list only)
                const nameMap = {
                    // Person
                    'person': 'Interviewee',

                    // Technology & Communication (strict interview items only)
                    'cell phone': 'Mobile Phone',
                    'laptop': 'Laptop',
                    'keyboard': 'Keyboard',
                    'mouse': 'Computer Mouse',

                    // Writing & Documentation (only clear items)
                    'book': 'Book/Document',

                    // Furniture & Setup (basic interview setup)
                    'chair': 'Chair',
                    'dining table': 'Desk/Table',

                    // Personal Items (common in interviews)
                    'bottle': 'Water Bottle',
                    'cup': 'Cup/Mug'
                };

                return nameMap[className] || className.charAt(0).toUpperCase() + className.slice(1);
            }

            getObjectIcon(className) {
                // Handle generic object case
                if (className === 'object') {
                    return 'fa-cube';
                }

                // Return appropriate FontAwesome icon for interview-relevant objects only
                const iconMap = {
                    // Person
                    'person': 'fa-user-tie',

                    // Technology & Communication (strict interview items only)
                    'cell phone': 'fa-mobile-alt',
                    'laptop': 'fa-laptop',
                    'keyboard': 'fa-keyboard',
                    'mouse': 'fa-mouse',

                    // Writing & Documentation (only clear items)
                    'book': 'fa-book',

                    // Furniture & Setup (basic interview setup)
                    'chair': 'fa-chair',
                    'dining table': 'fa-table',

                    // Personal Items (common in interviews)
                    'bottle': 'fa-wine-bottle',
                    'cup': 'fa-coffee'
                };

                return iconMap[className] || 'fa-cube';
            }

            getObjectColor(className) {
                // Generate consistent colors for different object types
                const colors = [
                    'linear-gradient(135deg, #007bff, #0056b3)',
                    'linear-gradient(135deg, #28a745, #1e7e34)',
                    'linear-gradient(135deg, #dc3545, #c82333)',
                    'linear-gradient(135deg, #ffc107, #e0a800)',
                    'linear-gradient(135deg, #17a2b8, #138496)',
                    'linear-gradient(135deg, #6f42c1, #59359a)',
                    'linear-gradient(135deg, #fd7e14, #e55100)',
                    'linear-gradient(135deg, #20c997, #17a085)',
                    'linear-gradient(135deg, #e83e8c, #d91a72)',
                    'linear-gradient(135deg, #6c757d, #545b62)'
                ];

                // Use hash of class name to get consistent color
                let hash = 0;
                for (let i = 0; i < className.length; i++) {
                    hash = className.charCodeAt(i) + ((hash << 5) - hash);
                }

                return colors[Math.abs(hash) % colors.length];
            }
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.dashboard = new MinimalDashboard();

            // Start periodic calibrated values updater
            setInterval(() => {
                if (window.dashboard && window.dashboard.latestData) {
                    console.log('Periodic calibrated values update');
                    window.dashboard.updateCalibratedValuesDisplay();
                }
            }, 3000); // Update every 3 seconds

            // Data logging for debugging
            setInterval(() => {
                if (window.dashboard && window.dashboard.latestData) {
                    console.log('=== RECEIVED DATA ===');
                    console.log('Full data:', window.dashboard.latestData);
                    if (window.dashboard.latestData.video) {
                        console.log('Video data:', window.dashboard.latestData.video);
                    }
                    if (window.dashboard.latestData.audio) {
                        console.log('Audio data:', window.dashboard.latestData.audio);
                    }
                    if (window.dashboard.latestData.calibration) {
                        console.log('Calibration data:', window.dashboard.latestData.calibration);
                    }
                }
            }, 3000);
        });
    </script>
</body>

</html>